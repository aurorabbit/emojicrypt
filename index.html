<meta charset=utf-8>
<title>emojicrypt.com â€“ Secure your tweets and toots~</title>



<!-- DOM goes here -->
<div></div>



<!-- scrypt-js -->
<!-- load before exports is defined -->
<!-- https://github.com/ricmoo/scrypt-js -->
<script src=scrypt-js/thirdparty/setImmediate.js></script>
<script src=scrypt-js/thirdparty/unorm.js></script>
<script src=scrypt-js/thirdparty/buffer.js></script>
<script src=scrypt-js/scrypt.js></script>



<!-- generated emoji256 from base-emoji/emojis.json -->
<!-- from https://github.com/pfrazee/base-emoji -->
<script src=js/emoji256.js></script>
<script>
// variables for pfrazee-base-emoji.js to load
var exports = {};
var emojis = emoji256;
</script>

<!-- patched base-emoji/index.js -->
<script src=js/pfrazee-base-emoji.js></script>



<!-- application code -->
<script>
var protocol = {
    1: {
        // v1 protocol
        // 1 header emoji
        // 4 or 6 salt emojis
        // uses emoji256 set, from github.com/pfrazee/base-emoji
        // uses scrypt
        // N = 10 to 17, r = 8 or 12, salt length = 4 (32b) or 6 (48b) emojis
        //// header bit arrangement:
        ////  version      3 bits  always 0b001
        ////  scrypt N     3 bits  N = bits+10, i.e. 10 to 17
        ////  scrypt r     1 bit   r = 4*(bit+2), i.e. 8 or 12
        ////  salt length  1 bit   s = 2*(bit+2), i.e. 4 or 6 emojis
        decodeHeader: function(header) {
            if (typeof(header) != "number")
                throw new Error("Protocol header must be a number.");
            
            // unpack bits
            var v = header >> 5 & 0b111;  // version
            var N = header >> 2 & 0b111;  // scrypt N
            var r = header >> 1 & 0b1;    // scrypt r
            var s = header >> 0 & 0b1;    // salt size
            
            // verify the version
            if (v != 1) throw new Error("Not v1 protocol data.");
            
            // normalise the values
            N = N + 10;
            r = 4*(r + 2);
            s = 2*(s + 2);
            
            return { N: N, r: r, s: s };
        },
        // v1 encoding arguments
        //// N          scrypt N factor, between 10 and 17
        //// large_r    if truthy, scrypt r = 12, else r = 8
        //// large_salt if truthy, salt len = 6 emojis, else salt len = 4 emojis
        encodeHeader: function(N, large_r, large_salt) {
            var version, r, s;
            
            version = 1;
            
            // duck type for r and s
            r = !!large_r;
            s = !!large_salt;
            
            // sanity check for N, we"ll play fast and loose with r and s
            if (typeof(N) != "number") throw new Error("N must be a number.");
            if (N < 10) throw new Error("N too small.");
            if (N > 17) throw new Error("N too large.");
            // shrink N
            N = N - 10;
            
            // pack the values into a number
            return version << 5 | N << 2 | r << 1 | s;
        },
    },
};



function error(e) { return e; }



function decode(string) {
    var params, version, header;
    
    if (typeof(string) !== "string") return error("Invalid string.");
    // https://github.com/pfrazee/base-emoji/blob/76ed2427/index.js#L55-L75
    string = getSymbols(string);
    
    header = emoji256.chars.indexOf(string[0]);
    if (header == -1) return error("Emoji not found.");
    
    version = header >> 5;
    
    if (!protocol[version]) return error("Cannot parse this data");
    
    try {
        params = protocol[version].decodeHeader(header);
    } catch(e) {
        error(e.message);
    }
    
    return params; // demo for now
    
    // TODO
    
}


var header = emoji256.chars[protocol[1].encodeHeader(14, false, true)];
console.log(decode(header));
</script>


